# Single line comments start with a hash(tag) symbol, like this
/*
    Multi-line comments are possible, too,
    like this!
*/

# Requirements come after module declaration, but are not required
# These are '.blt' files that will be parsed and loaded before this one
# If the '.blt' is ommitted, it will be added automatically
require "core/file1";

# Variable definitions look like variable assignments
variableExample1 = 2;

# Definitions can have an explicit type declaration to default the value to null
variableExample2 of VariableType;

# Variables can have an explicit type declaration and a value, though there is generally little reason to do this
variableExample3 of String = "Hello, I'm Dom";

exampleBoolean = false;
differentBooleanVariable = true;

# If-statements don't require parenthesis
if exampleBoolean {
    testFunction;
} else differentBooleanVariable {   # Else-if blocks don't require an "else if", "elif", or similar special keyword
    anotherTestFunction;
} else {
    finalTestFunction;
}

# Functions are defined with the "def" keyword and parenthesis
def anotherTestFunction() {
    
}

# The return type can be explicitly declared, though it is generally
# inferred
def testFunction() of Timone {
}

def finalTestFunction() {
}

# Argument types will be inferred if possible
def greet(firstName, lastName) {
    print @"Hello, #{firstName} #{lastName}";
}

class SimpleClass {
    def sayHelloWorld() {
        print "Hello world!";
    }
}

class Person {
    def _(firstName, lastName) {
        @firstName = firstName;
        @lastName = lastName;
    }
    
    def greet() {
        print @"Hello, #{@firstName} #{@lastName}!";
    }
    
    # Binary operators can be overridden
    def +(other) {
        return @"#{@firstName} #{@lastName} and #{other.firstName} #{other.lastName}";
    }
    
    # As well as unary operators
    def -() {
        return @"Deceased #{@firstName} #{@lastName}";
    }
    
    # Getters
    def firstName() {
        @firstName
    }
    def lastName() {
        @lastName
    }
}

distance = 9.45;
print 5 + (-(8 * 3) / 5) * ((fib abs(distance)) / 927.67);

print (fib abs(5)) * 5;

# You can square expressions like this:
print 5**;      # 25

# Or square root them:
print 25//;     # 5

# Or nth-power them:
print 2 ** 3;   # 8

# Or nth-root them:
print 8 // 3;   # 2

print 4** + 7 * 2 + 18; # 48

# Referencing variables and functions of a class:
personJimmy = Person.new "Jimmy", "Bobby";
personJimmy.greet;

personJimette = Person.new "Jimette", "Francis";
personJimette.greet;

print personJimmy + personJimette;

print -personJimmy;

# Values can be returned using "return <EXPRESSION>;"
# or "<EXPRESSION>" without the semicolon:
def add(a, b) { # Type declarations are not required for these arguments because the methods are type-inspecific.
                # As long as 'a' implements the '+' operator and accepts a parameter of type 'b', compilation will succeed.
    a + b
}
